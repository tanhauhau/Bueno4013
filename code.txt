package com.client.cache;

import com.client.Client;
import com.client.fucker.LastModifiedFucker;

import java.io.IOException;
import java.util.Date;
import java.util.HashMap;
import java.util.Set;

/**
 * Created by lhtan on 23/3/16.
 */
public abstract class Cache {
    private final int freshness;
    private final LastModifiedFucker lastModifiedFucker;

    protected HashMap<String, Record> cacheTable;

    /**
     * @param freshness number of second
     */
    public Cache(int freshness) {
        this.freshness = freshness;
        this.lastModifiedFucker = new LastModifiedFucker();
        this.cacheTable = new HashMap<>();
    }

    public boolean cacheAvailable(Client client, String filename) throws IOException{
        if (!this.cacheTable.containsKey(filename)){
            System.out.println(String.format("   FileCache >> cache miss for file ", filename));
            //1. cache miss
            return false;
        }else{
            //2. cache hit
            Record cacheRecord = this.cacheTable.get(filename);
            if (cacheRecord.isFresh()){
                //2.1. cache is fresh
                return true;
            }else{
                //2.2. cache is sour
                long lastModified = this.lastModifiedFucker.lastUpdate(client, filename);
                if (cacheRecord.isInvalid(lastModified)) {
                    System.out.println(String.format("   FileCache >> cache record is invalid, cache version: %s, server last modified: %s", new Date(cacheRecord.lastValidated).toString(), new Date(lastModified).toString()));
                    return false;
                }else{
                    //2.2.2. update tc
                    cacheRecord.setLastValidated(System.currentTimeMillis());
                    return true;
                }
            }
        }
    }
    public void updateCacheRecord(String filename){
        long lastValidate = System.currentTimeMillis();
        if (!cacheTable.containsKey(filename)){
            cacheTable.put(filename, createRecord(filename, lastValidate));
        }else {
            cacheTable.get(filename).setLastValidated(lastValidate);
        }
    }
    protected abstract Record createRecord(String filename, long lastValidate);
    public abstract String readFromCache(String filename, int offset, int length) throws IOException;
    public abstract void writeToCache(String filename, int offset, String content) throws IOException;
    public abstract void writeToCache(String filename, String content) throws IOException;

    public Set<String> getCachedSet(){
        return cacheTable.keySet();
    }

    public Record getCacheRecord(String filename){
        if (cacheTable.containsKey(filename)){
            return cacheTable.get(filename);
        }
        return null;
    }

    protected class Record {
        protected String filename;
        protected long lastValidated;

        public Record(String filename, long lastValidated) {
            this.filename = filename;
            this.lastValidated = lastValidated;
        }
        public void setLastValidated(long time){
            lastValidated = time;
        }
        public boolean isInvalid(long time) {
            return lastValidated < time;
        }
        public boolean isFresh(){
            return System.currentTimeMillis() - lastValidated < freshness * 1000;
        }
        @Override
        public String toString() {
            return String.format("%s, tc=%s, %s", filename, new Date(lastValidated).toString(), isFresh()?"fresh":"sour");
        }
    }
}
package com.client.cache;

import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.Date;

/**
 * Created by lhtan on 23/3/16.
 */
public class FileCache extends Cache {
    private final String folder;
    /**
     * @param folder cache folder path
     * @param freshness number of second
     */
    public FileCache(String folder, int freshness) {
        super(freshness);
        this.folder = folder;
    }

    @Override
    protected Cache.Record createRecord(String filename, long lastValidate) {
        Path path = Paths.get(folder, filename);
        return new FileRecord(filename, path.toString(), lastValidate);
    }

    public String readFromCache(String filename, int offset, int length) throws IOException{
        byte[] buffer = new byte[length];
        RandomAccessFile raf = new RandomAccessFile(getCacheFilePath(filename), "r");
        raf.seek(offset);
        raf.read(buffer, 0, length);
        return new String(buffer);
    }

    public void writeToCache(String filename, int offset, String content) throws IOException{
        updateCacheRecord(filename);
        RandomAccessFile raf = new RandomAccessFile(getCacheFilePath(filename), "rw");
        raf.seek(offset);
        raf.writeBytes(content);
        raf.close();
    }
    public void writeToCache(String filename, String content) throws IOException{
        updateCacheRecord(filename);
        String path = getCacheFilePath(filename);
        Path filepath = Paths.get(path);
        if (!Files.exists(filepath)) Files.createFile(filepath);
        Files.write(filepath, content.getBytes(), StandardOpenOption.WRITE);
    }

    public String getCacheFilePath(String filename){
        if (cacheTable.containsKey(filename)){
            return ((FileRecord) cacheTable.get(filename)).cacheFilepath;
        }
        return null;
    }

    private class FileRecord extends Cache.Record {
        private String cacheFilepath;

        public FileRecord(String filename, String cacheFilepath, long lastValidated) {
            super(filename, lastValidated);
            this.cacheFilepath = cacheFilepath;
        }
        @Override
        public String toString() {
            return String.format("%s, tc=%s, %s", filename, new Date(lastValidated).toString(), isFresh()?"fresh":"sour");
        }
    }
}
package com.client.cache;

import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.Date;

/**
 * Created by lhtan on 23/3/16.
 */
public class MemoryCache extends Cache {
    private final String folder;
    /**
     * @param folder cache folder path
     * @param freshness number of second
     */
    public MemoryCache(String folder, int freshness) {
        super(freshness);
        this.folder = folder;
    }

    @Override
    protected Record createRecord(String filename, long lastValidate) {
        Path path = Paths.get(folder, filename);
        return new FileRecord(filename, path.toString(), lastValidate);
    }

    public String readFromCache(String filename, int offset, int length) throws IOException{
        byte[] buffer = new byte[length];
        RandomAccessFile raf = new RandomAccessFile(getCacheFilePath(filename), "r");
        raf.seek(offset);
        raf.read(buffer, 0, length);
        return new String(buffer);
    }

    public void writeToCache(String filename, int offset, String content) throws IOException{
        RandomAccessFile raf = new RandomAccessFile(getCacheFilePath(filename), "rw");
        raf.seek(offset);
        raf.writeBytes(content);
        raf.close();
        updateCacheRecord(filename);
    }
    public void writeToCache(String filename, String content) throws IOException{
        String path = getCacheFilePath(filename);
        Path filepath = Paths.get(path);
        if (!Files.exists(filepath)) Files.createFile(filepath);
        Files.write(filepath, content.getBytes(), StandardOpenOption.WRITE);
        updateCacheRecord(filename);
    }

    public String getCacheFilePath(String filename){
        if (cacheTable.containsKey(filename)){
            return ((FileRecord) cacheTable.get(filename)).cacheFilepath;
        }
        return null;
    }

    private class FileRecord extends Record {
        private String cacheFilepath;

        public FileRecord(String filename, String cacheFilepath, long lastValidated) {
            super(filename, lastValidated);
            this.cacheFilepath = cacheFilepath;
        }
        @Override
        public String toString() {
            return String.format("%s, tc=%s, %s", filename, new Date(lastValidated).toString(), isFresh()?"fresh":"sour");
        }
    }
}
package com.client;

import com.Console;
import com.client.fucker.Fucker;
import com.client.pack.Pack;
import com.client.socket.*;
import com.client.socket.Socket;
import com.sun.tools.javac.util.Assert;

import java.io.IOException;
import java.net.*;
import java.util.Arrays;
import java.util.HashMap;

public class Client {
    public static final int BOBO_REQUEST = 0;
    public static final int READ_REQUEST = 1;
    public static final int WRITE_REQUEST = 2;
    public static final int REGISTER_REQUEST = 3;
    public static final int SIZE_REQUEST = 4;
    public static final int DOUBLE_REQUEST = 5;
    public static final int LAST_MODIFIED_REQUEST = 6;

    //Address and Port
    private String mServerIPAddress = "192.168.0.255";
    private int mServerPort = 6789;
    private static final int BUFFER_SIZE = 1048576; //1MB
    private static final byte EMPTY = 0;

    //UDP Socket
    private Socket mSocket = null;
    private InetAddress mServerAddress = null;
    private int mTimeout = 0;

    //fuckers
    private HashMap<Integer, Fucker> fuckers;

    //buffer
    byte[] buffer = new byte[BUFFER_SIZE];

    private long messageId = 0;

    public Client(String serverIPAddress, int serverPort, int timeout) throws UnknownHostException, SocketException {
        this.mServerIPAddress = serverIPAddress;
        this.mServerPort = serverPort;
        this.mServerAddress = InetAddress.getByName(mServerIPAddress);
        this.fuckers = new HashMap<>();
        this.mTimeout = timeout;
        this.mSocket = new BoboSocket(new DatagramSocket());
        this.mSocket.setTimeout(this.mTimeout);
    }

    public Client use(int requestCode, Fucker fucker){
        this.fuckers.put(requestCode, fucker);
        return this;
    }

    /**
     *
     * @param prob probability of success sending out a packet
     * @return
     * @throws SocketException
     */
    public Client makeItNoobInSending(double prob) throws SocketException{
        this.mSocket = new NoobSendSocket(this.mSocket, prob);
        return this;
    }
    /**
     *
     * @param prob probability of success sending out a packet
     * @return
     * @throws SocketException
     */
    public Client makeItNoobInReceiving(double prob) throws SocketException{
        this.mSocket = new NoobReceiveSocket(this.mSocket, prob);
        return this;
    }
    /**
     * @param time time in ms lag when receiving and sending
     * @return
     * @throws SocketException
     */
    public Client makeItLag(int time) throws SocketException{
        this.mSocket = new LagSocket(this.mSocket, time);
        return this;
    }
    /**
     * @param prob probablitiy of not kisiao
     * @return
     * @throws SocketException
     */
    public Client makeItKisiao(double prob) throws SocketException{
        this.mSocket = new KisiaoSocket(this.mSocket, prob);
        return this;
    }

    public void printMenu(){
        for (Integer option: fuckers.keySet()) {
            Console.println(String.format("%d. %s", option, fuckers.get(option).getStupidTitle()));
        }
    }

    public void stop(){
        Assert.checkNonNull(mSocket, "Socket hasn't instantiated, you mother fucker..");
        mSocket.close();
    }

    public void execute(int option, Console console) throws IOException {
        if (this.fuckers.containsKey(option)){
            Fucker fucker = this.fuckers.get(option);
            fucker.fuckUser(console, this);
        }
    }

    public void setTimeout(int timeout) throws SocketException {
        this.mSocket.setTimeout(timeout);
    }

    public void resetTimeout() throws SocketException {
        this.mSocket.setTimeout(this.mTimeout);
    }

    public void send(Pack request) throws IOException{
        this.mSocket.send(request, mServerAddress, mServerPort);
    }

    public DatagramPacket receive() throws IOException {
        cleanBuffer();
        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
        this.mSocket.receive(packet);
        return packet;
    }

    private void cleanBuffer() {
        Arrays.fill(buffer, EMPTY);
    }
    public long getMessageId(){
        return messageId ++;
    }
}
package com.client.fucker;

import com.Console;
import com.client.Client;
import com.client.cache.Cache;

import java.io.IOException;

/**
 * Created by lhtan on 23/3/16.
 */
public class CacheDetailFucker extends Fucker {

    private final Cache cache;
    public CacheDetailFucker(Cache cache) {
        super(null);
        this.cache = cache;
    }

    @Override
    public void fuckUser(Console scanner, Client client) throws IOException {
        Console.println(" >>> Cached Listing <<< ");
        int count = 0;
        for(String filename : cache.getCachedSet()){
            System.out.println(cache.getCacheRecord(filename));
            count ++;
        }
        Console.println(String.format(" Total %d file", count));
        Console.println(" >>> Cache Listing <<< ");
    }

    @Override
    public String getStupidTitle() {
        return "List of Cache";
    }
}
package com.client.fucker;

import com.Console;
import com.client.Client;
import com.client.cache.Cache;
import com.client.pack.OneByteInt;
import com.client.pack.Pack;
import com.client.pack.Unpack;

import java.io.IOException;

/**
 * Created by lhtan on 23/3/16.
 */
public class CacheFucker extends Fucker {

    private final static String DATA = "data";
    private final Cache cache;
    private final SizeFucker sizeFucker;

    public CacheFucker(Cache cache) {
        super(new Unpack.Builder()
                .setType(DATA, Unpack.TYPE.STRING)
                .build());
        this.cache = cache;
        this.sizeFucker = new SizeFucker();
    }

    public boolean loadCache(Client client, String filename) throws IOException {
        if(cache.cacheAvailable(client, filename)) {
            System.out.println("  CacheFucker >> FileCache is available, do nothing");
            return true;
        } else {
            System.out.println("  CacheFucker >> Load FileCache");
            long fileSizeInByte = this.sizeFucker.getFileSize(client, filename);

            long messageId = client.getMessageId();

            Pack request = new Pack.Builder()
                    .setValue("request", new OneByteInt(Client.READ_REQUEST))
                    .setValue("id", messageId)
                    .setValue("filename", filename)
                    .setValue("offset", 0L)
                    .setValue("length", fileSizeInByte)
                    .build();

            client.send(request);

            Unpack.Result result = keepTryingUntilReceive(client, request, messageId);

            if (isStatusOK(result)) {
                String data = result.getString(DATA);

                Console.println("  CacheFucker >> Update FileCache");
                cache.writeToCache(filename, data);
                return true;
            }else{
                Console.println(String.format("  CacheFucker >> Error: %s", result.getString(DATA)));
                return false;
            }
        }
    }

    @Override
    public void fuckUser(Console scanner, Client client) throws IOException {
        String filename = scanner.askForString("Name of that video");
        loadCache(client, filename);
    }

    @Override
    public String getStupidTitle() {
        return "Cache Youtube videos";
    }
}
package com.client.fucker;

import com.Console;
import com.client.Client;
import com.client.cache.Cache;
import com.client.pack.Unpack;

import java.io.IOException;

/**
 * Created by lhtan on 23/3/16.
 */
public class CacheReadingFucker extends Fucker {

    private final static String DATA = "data";
    private final Cache cache;
    private final CacheFucker cacheFucker;

    public CacheReadingFucker(Cache cache) {
        super(new Unpack.Builder()
                .setType(DATA, Unpack.TYPE.STRING)
                .build());
        this.cache = cache;
        this.cacheFucker = new CacheFucker(cache);
    }

    @Override
    public void fuckUser(Console scanner, Client client) throws IOException {
        String filename = scanner.askForString("Name of that porn");
        int offset = scanner.askForInteger("Episode Number");
        int length = scanner.askForInteger("Number of episodes to watch");

        Console.info("  CacheReadingFucker >> Loading cache");
        if(this.cacheFucker.loadCache(client, filename)) {

            String data = cache.readFromCache(filename, offset, length);

            Console.println(String.format("  CacheReadingFucker >> Data: '%s'", data));
        }else{
            Console.println("  CacheReadingFucker >> Server Error");
        }
    }

    @Override
    public String getStupidTitle() {
        return "Watch Porn Hub (Cache)";
    }
}
package com.client.fucker;

import com.Console;
import com.client.Client;
import com.client.cache.Cache;
import com.client.pack.OneByteInt;
import com.client.pack.Pack;
import com.client.pack.Unpack;

import java.io.IOException;

/**
 * Created by lhtan on 23/3/16.
 */
public class CacheWritingFucker extends Fucker {

    private final Cache cache;
    private final CacheFucker cacheFucker;

    public CacheWritingFucker(Cache cache) {
        super(null);
        this.cache = cache;
        this.cacheFucker = new CacheFucker(cache);
    }


    @Override
    public void fuckUser(Console scanner, Client client) throws IOException {
        String filename = scanner.askForString("Whisper to who?");
        int offset = scanner.askForInteger("Starting from where");
        String content = scanner.askForString("Content");

        long messageId = client.getMessageId();
        Pack request = new Pack.Builder()
                .setValue("request", new OneByteInt(Client.WRITE_REQUEST))
                .setValue("id", messageId)
                .setValue("filename", filename)
                .setValue("offset", offset)
                .setValue("content", content)
                .build();

        client.send(request);

        Unpack.Result result = keepTryingUntilReceive(client, request, messageId);

        if (isStatusOK(result)) {
            Console.println("  CacheWritingFucker >> write success");

            //update cache as well
            if(!cache.cacheAvailable(client, filename)){
                Console.info("  CacheWritingFucker >> FileCache is not available");
                Console.info("  CacheWritingFucker >> Load FileCache");
                this.cacheFucker.loadCache(client, filename);
            }else {
                Console.info("  CacheWritingFucker >> Update cache");
                cache.writeToCache(filename, offset, content);
            }
        }else{
            Console.println("  CacheWritingFucker >> write failed");
        }
    }

    @Override
    public String getStupidTitle() {
        return "Whisper racist contents into the ears (Cache)";
    }
}
package com.client.fucker;

import com.Console;
import com.client.Client;
import com.client.pack.OneByteInt;
import com.client.pack.Pack;
import com.client.pack.Unpack;

import java.io.IOException;

/**
 * Created by lhtan on 23/3/16.
 */
public class DoubleFucker extends Fucker {

    public DoubleFucker() {
        super(null);
    }

    @Override
    public void fuckUser(Console scanner, Client client) throws IOException {
        String filename = scanner.askForString("Filename");
        long messageId = client.getMessageId();
        Pack request = new Pack.Builder()
                .setValue("request", new OneByteInt(Client.DOUBLE_REQUEST))
                .setValue("id", messageId)
                .setValue("filename", filename)
                .build();

        client.send(request);

        Unpack.Result result = keepTryingUntilReceive(client, request, messageId);

        if (isStatusOK(result)) {
            Console.println("  DoubleFucker >> Success");
        }else{
            Console.println("  DoubleFucker >> Failed");
        }
    }

    @Override
    public String getStupidTitle() {
        return "Non-idempotent, double the excitement!";
    }
}
package com.client.fucker;

import com.Console;
import com.client.Client;
import com.client.pack.OneByteInt;
import com.client.pack.Pack;
import com.client.pack.Unpack;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.SocketTimeoutException;

/**
 * Created by lhtan on 22/3/16.
 */
public abstract class Fucker {

    private final Unpack unpack;

    protected static final String STATUS = "status";
    protected static final String REQUEST_ID = "id";

    protected Fucker(Unpack unpack){
        this.unpack = new Unpack.Builder()
                .setType(STATUS, Unpack.TYPE.ONE_BYTE_INT)
                .setType(REQUEST_ID, Unpack.TYPE.LONG)
                .build()
                .include(unpack);
    }

    final protected Unpack.Result unpack(byte[] data){
        return this.unpack.parseByteArray(data);
    }

    final protected boolean isStatusOK(Unpack.Result result){
        OneByteInt status = result.getOneByteInt(STATUS);
        if (status != null){
            return status.getValue() == 0;
        }
       return false;
    }
    final protected boolean isRequestIdEqual(Unpack.Result result, long id){
        Long requestId = result.getLong(REQUEST_ID);
        if (requestId != null){
            return requestId == id;
        }
        return false;
    }

    final protected Unpack.Result keepTryingUntilReceive(Client client, Pack pack, long requestID) throws IOException{
        while(true){
            try {
                DatagramPacket packet = client.receive();
                Unpack.Result result = unpack(packet.getData());
                if (isRequestIdEqual(result, requestID)) {
                    return result;
                }
            }catch(SocketTimeoutException e){
                Console.info("  Fucker >> Timeout");
                Console.info("  Fucker >> Resend");
                client.send(pack);
            }
        }
    }

    public abstract void fuckUser(Console scanner, Client client) throws IOException;

    public abstract String getStupidTitle();
}
package com.client.fucker;

import com.Console;
import com.client.Client;
import com.client.pack.OneByteInt;
import com.client.pack.Pack;
import com.client.pack.Unpack;

import java.io.IOException;
import java.util.Date;

/**
 * Created by lhtan on 23/3/16.
 */
public class LastModifiedFucker extends Fucker {

    private final static String TIME = "time";

    public LastModifiedFucker() {
        super(new Unpack.Builder()
                .setType(TIME, Unpack.TYPE.LONG)
                .build());
    }

    public long lastUpdate(Client client, String filename) throws IOException{
        long messageId = client.getMessageId();
        Pack request = new Pack.Builder()
                .setValue("request", new OneByteInt(Client.LAST_MODIFIED_REQUEST))
                .setValue("id", messageId)
                .setValue("filename", filename)
                .build();

        client.send(request);

        Unpack.Result result = keepTryingUntilReceive(client, request, messageId);

        if (!isStatusOK(result)) {
            return -1;
        }
        return result.getLong(TIME);
    }

    @Override
    public void fuckUser(Console scanner, Client client) throws IOException {
        String filename = scanner.askForString("Name of that bitch");
        long time = lastUpdate(client, filename);
        if (time == -1){
            Console.println("  LastModifiedFucker >> Server error occured");
        }else {
            Date date = new Date(time);
            Console.println(String.format("  LastModifiedFucker >> Last modified time for %s is %s", filename, date.toString()));
        }
    }

    @Override
    public String getStupidTitle() {
        return "The last time you fuck that bitch";
    }
}
package com.client.fucker;

import com.Console;
import com.client.Client;
import com.client.pack.OneByteInt;
import com.client.pack.Pack;
import com.client.pack.Unpack;

import java.io.IOException;

/**
 * Created by lhtan on 23/3/16.
 */
public class PingFucker extends Fucker {

    private final static String DATA = "data";

    public PingFucker() {
        super(new Unpack.Builder()
                .setType(DATA, Unpack.TYPE.STRING)
                .build());
    }

    @Override
    public void fuckUser(Console scanner, Client client) throws IOException {
        String message = scanner.askForString("Poke what?");
        long messageId = client.getMessageId();
        Pack ping = new Pack.Builder()
                .setValue("request", new OneByteInt(Client.BOBO_REQUEST))
                .setValue("id", messageId)
                .setValue("message", message)
                .build();
        client.send(ping);

        /*
        DatagramPacket packet = client.receive();
        Unpack.Result result = unpack(packet.getData());
        if (isStatusOK(result)){
            System.out.println(String.format("Received : %s", result.getString(DATA)));
        }
        */

        Unpack.Result result = keepTryingUntilReceive(client, ping, messageId);
        if (isStatusOK(result)) {
            Console.println(String.format("Received : %s", result.getString(DATA)));
        }else{
            Console.println("Failed");
        }

    }

    @Override
    public String getStupidTitle() {
        return "MILF -- Poking Pussy";
    }
}
package com.client.fucker;

import com.Console;
import com.client.Client;
import com.client.pack.OneByteInt;
import com.client.pack.Pack;
import com.client.pack.Unpack;

import java.io.IOException;

/**
 * Created by lhtan on 23/3/16.
 */
public class ReadingFucker extends Fucker {

    private final static String DATA = "data";

    public ReadingFucker() {
        super(new Unpack.Builder()
                .setType(DATA, Unpack.TYPE.STRING)
                .build());
    }

    @Override
    public void fuckUser(Console scanner, Client client) throws IOException {
        String filename = scanner.askForString("Name of that porn");
        int offset = scanner.askForInteger("Episode Number");
        int length = scanner.askForInteger("Number of episodes to watch");

        long messageId = client.getMessageId();

        Pack request = new Pack.Builder()
                .setValue("request", new OneByteInt(Client.READ_REQUEST))
                .setValue("id", messageId)
                .setValue("filename", filename)
                .setValue("offset", (long) offset)
                .setValue("length", (long) length)
                .build();

        client.send(request);

        Unpack.Result result = keepTryingUntilReceive(client, request, messageId);

        if (isStatusOK(result)) {
            Console.println(String.format("  ReadingFucker >> Data: '%s'", result.getString(DATA)));
        }else{
            Console.println(String.format("  ReadingFucker >> Error: %s", result.getString(DATA)));
        }
    }

    @Override
    public String getStupidTitle() {
        return "Watch Porn Hub";
    }
}
package com.client.fucker;

import com.Console;
import com.client.Client;
import com.client.cache.Cache;
import com.client.pack.OneByteInt;
import com.client.pack.Pack;
import com.client.pack.Unpack;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.SocketTimeoutException;

/**
 * Created by lhtan on 23/3/16.
 */
public class RegisterFucker extends Fucker {

    private final static String STATUS = "datastatus";
    private final static String STATUS2 = "datastatus2";
    private final static String DATA = "data";
    private final Cache cache;

    public RegisterFucker(Cache cache) {
        super(new Unpack.Builder()
                .setType(STATUS, Unpack.TYPE.ONE_BYTE_INT)
                .setType(DATA, Unpack.TYPE.STRING)
                .setType(STATUS2, Unpack.TYPE.ONE_BYTE_INT)
                .build());
        this.cache = cache;
    }

    @Override
    public void fuckUser(Console scanner, Client client) throws IOException {
        String filename = scanner.askForString("Name of the chiobu");
        int timeout = scanner.askForInteger("Peep for how long (hour)");

        long requestID = client.getMessageId();
        Pack request = new Pack.Builder()
                .setValue("request", new OneByteInt(Client.REGISTER_REQUEST))
                .setValue("id", requestID)
                .setValue("filename", filename)
                .setValue("timeout", timeout)
                .build();

        client.send(request);

        Unpack.Result registerResult = keepTryingUntilReceive(client, request, requestID);
        if (!isStatusOK(registerResult)){
            Console.println("  RegisterFucker >> No Such File");
            return;
        }else{
            Console.println("  RegisterFucker >> Start observing file change");
        }

        long timeStart = System.currentTimeMillis();
        long timeEnd = timeStart + timeout * 1000; //timeout * 1000ms

        while (System.currentTimeMillis() < timeEnd) {
            try {
                client.setTimeout((int) (timeEnd - System.currentTimeMillis()));

                DatagramPacket packet = client.receive();
                Unpack.Result result = unpack(packet.getData());

                if (!isStatusOK(result)) continue;
                if (!isRequestIdEqual(result, requestID)) continue;

                OneByteInt status = result.getOneByteInt(STATUS);
                String data = result.getString(DATA);
                OneByteInt status2 = result.getOneByteInt(STATUS2);

                if (!checkValidity(status, status2)) continue;
                if (data == null)   continue;

                Console.println(String.format("  RegisterFucker >> DataChanged: '%s'", data));
                cache.writeToCache(filename, data);
            }catch (SocketTimeoutException e){
                Console.info("  RegisterFucker >> Timeout");
            }
        }

        client.resetTimeout();
    }

    private boolean checkValidity(OneByteInt s1, OneByteInt s2){
        return s1 != null && s2 != null && (s1.getValue() & 0XFF) == 0b01010101 && (s2.getValue() & 0XFF) == 0b10101010;
    }

    @Override
    public String getStupidTitle() {
        return "Peeping chiobu bathing";
    }
}
package com.client.fucker;

import com.Console;
import com.client.Client;
import com.client.pack.OneByteInt;
import com.client.pack.Pack;
import com.client.pack.Unpack;

import java.io.IOException;

/**
 * Created by lhtan on 23/3/16.
 */
public class SizeFucker extends Fucker {

    private final static String SIZE = "size";

    public SizeFucker() {
        super(new Unpack.Builder()
                .setType(SIZE, Unpack.TYPE.LONG)
                .build());
    }

    public long getFileSize(Client client, String filename) throws IOException{
        long messageId = client.getMessageId();
        Pack request = new Pack.Builder()
                .setValue("request", new OneByteInt(Client.SIZE_REQUEST))
                .setValue("id", messageId)
                .setValue("filename", filename)
                .build();

        client.send(request);

        Unpack.Result result = keepTryingUntilReceive(client, request, messageId);

        if (isStatusOK(result)) {
            return result.getLong(SIZE);
        }else{
            return -1;
        }
    }

    @Override
    public void fuckUser(Console scanner, Client client) throws IOException {
        String filename = scanner.askForString("Name of the penis");
        
        long size = getFileSize(client, filename);
        if (size == -1){
            Console.println("  SizeFucker >> Not available");
        }else {
            Console.println(String.format("  SizeFucker >> Size: %s bytes", size));
        }
    }

    @Override
    public String getStupidTitle() {
        return "Size of the penis";
    }
}
package com.client.fucker;

import com.Console;
import com.client.Client;
import com.client.pack.OneByteInt;
import com.client.pack.Pack;
import com.client.pack.Unpack;

import java.io.IOException;

/**
 * Created by lhtan on 23/3/16.
 */
public class WritingFucker extends Fucker {

    public WritingFucker() {
        super(null);
    }


    @Override
    public void fuckUser(Console scanner, Client client) throws IOException {
        String filename = scanner.askForString("Whisper to who?");
        int offset = scanner.askForInteger("Starting from where");
        String content = scanner.askForString("Content");

        long messageId = client.getMessageId();
        Pack request = new Pack.Builder()
                .setValue("request", new OneByteInt(Client.WRITE_REQUEST))
                .setValue("id", messageId)
                .setValue("filename", filename)
                .setValue("offset", offset)
                .setValue("content", content)
                .build();

        client.send(request);

        Unpack.Result result = keepTryingUntilReceive(client, request, messageId);

        if (isStatusOK(result)) {
            Console.println("  WritingFucker >> write success");
        }else{
            Console.println("  WritingFucker >> write failed");
        }
    }

    @Override
    public String getStupidTitle() {
        return "Whisper racist contents into the ears";
    }
}
package com.client.pack;

/**
 * Created by lhtan on 22/3/16.
 */
public class OneByteInt {
    protected int value;

    public OneByteInt(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }
}
package com.client.pack;

import com.sun.tools.javac.util.Assert;

import java.util.ArrayList;
import java.util.HashMap;

/**
 * Created by lhtan on 22/3/16.
 */
public class Pack {

    private ArrayList<String> properties;
    private HashMap<String, Object> values;

    public Object getValue(String property){
        Assert.check(values.containsKey(property), "No such property lah, you mother fucker..");
        return values.get(property);
    }
    public byte[] getByteArray(){
        //1. calculate the size needed for the buffer array
        int size = 1;
        for (Object value : values.values()){
            if (value instanceof Integer){
                size += 4;
            }else if (value instanceof String){
                size += 4 + ((String) value).length();
            }else if (value instanceof Long){
                size += 8;
            }else if (value instanceof byte[]){
                size += 4 + ((byte[]) value).length;
            }else if (value instanceof OneByteInt){
                size += 1;
            }
        }
        //2. create the buffer
        byte[] buffer = new byte[size];
        //3. serialize the pack
        int index = 0;
        for (String property : properties){
            Object value = values.get(property);
            if (value instanceof Integer){
                index = intToByte((Integer) value, buffer, index);
            }else if (value instanceof String){
                index = intToByte(((String) value).length(), buffer, index);
                index = stringToByte((String) value, buffer, index);
            }else if (value instanceof Long){
                index = longToByte((Long) value, buffer, index);
            }else if (value instanceof byte[]){
                index = intToByte(((byte[]) value).length, buffer, index);
                System.arraycopy(value, 0, buffer, index, ((byte[]) value).length);
                index += ((byte[]) value).length;
            }else if (value instanceof OneByteInt){
                buffer[index ++] = (byte) (((OneByteInt) value).getValue() & 0xFF);
            }
        }
        //4. return the buffer
        return buffer;
    }
    //standardize use
    private int intToByte(int i, byte[] buffer, int index){
        buffer[index++] = (byte)((i >> 24) & 0xFF);
        buffer[index++] = (byte)((i >> 16) & 0xFF);
        buffer[index++] = (byte)((i >> 8) & 0xFF);
        buffer[index++] = (byte)((i) & 0xFF);
        return index;
    }

    private int stringToByte(String s, byte[] buffer, int index){
        for (byte b : s.getBytes()){
            buffer[index++] = b;
        }
        return index;
    }

    private int longToByte(long l, byte[] buffer, int index){
        buffer[index ++] = (byte)((l >> 56) & 0xFF);
        buffer[index ++] = (byte)((l >> 48) & 0xFF);
        buffer[index ++] = (byte)((l >> 40) & 0xFF);
        buffer[index ++] = (byte)((l >> 32) & 0xFF);
        buffer[index ++] = (byte)((l >> 24) & 0xFF);
        buffer[index ++] = (byte)((l >> 16) & 0xFF);
        buffer[index ++] = (byte)((l >>  8) & 0xFF);
        buffer[index ++] = (byte)((l >>  0) & 0xFF);
        return index;
    }

    private Pack() {
        this.properties = new ArrayList<>();
        this.values = new HashMap<>();
    }
    private void setValue(String property, Object value){
        this.properties.add(property);
        this.values.put(property, value);
    }
    public static class Builder{
        private Pack pack;
        public Builder() {
            pack = new Pack();
        }
        public Builder setValue(String property, Long value){
            return set(property, value);
        }
        public Builder setValue(String property, Integer value){
            return set(property, value);
        }
        public Builder setValue(String property, String value){
            return set(property, value);
        }
        public Builder setValue(String property, byte[] value){
            return set(property, value);
        }
        public Builder setValue(String property, OneByteInt value){
            return set(property, value);
        }
        private Builder set(String property, Object value){
            Assert.check(!pack.values.containsKey(property), "You already have this property dy lah, you mother fucker..");
            pack.setValue(property, value);
            return this;
        }
        public Pack build(){
            return pack;
        }
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        boolean has = false;
        for (String property : properties){
            if (has) sb.append(", ");
            Object value = values.get(property);
            if (value instanceof Integer){
                sb.append(property).append(": ").append((Integer) value);
            }else if (value instanceof String){
                sb.append(property).append(": \"").append(((String) value)).append("\"");
            }else if (value instanceof Long){
                sb.append(property).append(": ").append((Long) value);
            }else if (value instanceof byte[]){
                sb.append(property).append(": <byte array>");
            }else if (value instanceof OneByteInt){
                sb.append(property).append(": ").append(((OneByteInt) value).getValue());
            }
            has = true;
        }
        sb.append("}");
        return sb.toString();
    }
}
package com.client.pack;

import com.sun.tools.javac.util.Assert;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

/**
 * Created by lhtan on 22/3/16.
 */
public class Unpack {

    public enum TYPE{
        INTEGER, LONG, STRING, BYTE_ARRAY, ONE_BYTE_INT;
    }

    private ArrayList<String> properties;
    private HashMap<String, TYPE> values;

    public static class Result{
        HashMap<String, Object> map;

        public Result(HashMap<String, Object> map) {
            this.map = map;
        }
        public Integer getInt(String value){
            if (map.containsKey(value) && map.get(value) instanceof Integer){
                return (Integer) map.get(value);
            }
            return null;
        }
        public String getString(String value){
            if (map.containsKey(value) && map.get(value) instanceof String){
                return (String) map.get(value);
            }
            return null;
        }
        public Long getLong(String value){
            if (map.containsKey(value) && map.get(value) instanceof Long){
                return (Long) map.get(value);
            }
            return null;
        }
        public byte[] getByteArray(String value){
            if (map.containsKey(value) && map.get(value) instanceof byte[]){
                return (byte[]) map.get(value);
            }
            return null;
        }
        public OneByteInt getOneByteInt(String value){
            if (map.containsKey(value) && map.get(value) instanceof OneByteInt){
                return (OneByteInt) map.get(value);
            }
            return null;
        }
    }

    public Result parseByteArray(byte[] data){
        int offset = 0;
        HashMap<String, Object> map = new HashMap<>();
        for (String property : properties){
            TYPE value = values.get(property);
            switch (value){
                case INTEGER:
                    map.put(property, parseInt(data, offset));
                    offset += 4;
                    break;
                case LONG:
                    map.put(property, parseLong(data, offset));
                    offset += 8;
                    break;
                case STRING:
                    int length = parseInt(data, offset);
                    map.put(property, parseString(data, offset + 4, length));
                    offset += 4 + length;
                    break;
                case ONE_BYTE_INT:
                    map.put(property, new OneByteInt(data[offset] & 0xFF));
                    offset += 1;
                    break;
                case BYTE_ARRAY:
                    int byte_length = parseInt(data, offset);
                    map.put(property, Arrays.copyOfRange(data, offset + 4, offset + 4 + byte_length));
                    break;
            }
        }
        //4. return the result
        return new Result(map);
    }

    private Integer parseInt(byte[] data, int offset){
        try{
            int i = ((int)data[offset ++] & 0xFF) << 24;
            i += ((int)data[offset ++] & 0xFF) << 16;
            i += ((int)data[offset ++] & 0xFF) << 8;
            i += ((int)data[offset ++] & 0xFF);
            return i;
        }catch (IndexOutOfBoundsException e){
            return null;
        }
    }
    private Long parseLong(byte[] data, int offset){
        try{
            return  ((data[offset ++] & 0xFFL) << 56) |
                    ((data[offset ++] & 0xFFL) << 48) |
                    ((data[offset ++] & 0xFFL) << 40) |
                    ((data[offset ++] & 0xFFL) << 32) |
                    ((data[offset ++] & 0xFFL) << 24) |
                    ((data[offset ++] & 0xFFL) << 16) |
                    ((data[offset ++] & 0xFFL) <<  8) |
                    ((data[offset ++] & 0xFFL) <<  0) ;
        }catch (IndexOutOfBoundsException e){
            return null;
        }
    }
    private String parseString(byte[] data, int offset, int length){
        try{
            StringBuilder sb = new StringBuilder();
            for (int i=0; i<length; i++, offset++){
                sb.append((char) data[offset]);
            }
            return sb.toString();
        }catch (IndexOutOfBoundsException e){
            return null;
        }
    }

    private Unpack() {
        this.properties = new ArrayList<>();
        this.values = new HashMap<>();
    }
    public Unpack include(Unpack unpack){
        if (unpack != null) {
            for (String prop : unpack.properties) {
                Assert.check(!this.properties.contains(prop), String.format("You already have this property %s ley, you mother fucker", prop));
            }
            this.properties.addAll(unpack.properties);
            this.values.putAll(unpack.values);
        }
        return this;
    }

    public static class Builder{
        private Unpack pack;
        public Builder() {
            pack = new Unpack();
        }
        public Builder setType(String property, TYPE type){
            Assert.check(!pack.values.containsKey(property), "You already have this property dy lah, you mother fucker..");
            pack.properties.add(property);
            pack.values.put(property, type);
            return this;
        }
        public Unpack build(){
            return pack;
        }
    }
}
package com.client.socket;

import com.Console;
import com.client.pack.Pack;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.util.Date;

/**
 * Created by lhtan on 22/3/16.
 */
public class BoboSocket implements Socket {
    private DatagramSocket socket;
    public BoboSocket(DatagramSocket socket){
        this.socket = socket;
    }
    public void send(Pack pack, InetAddress address, int port) throws IOException {
        Console.info(String.format(" Socket >> Packing %s", pack.toString()));
        byte[] message = pack.getByteArray();
        DatagramPacket packet = new DatagramPacket(message, message.length, address, port);
        send(packet);
    }
    public void send(DatagramPacket p) throws IOException {
        Console.info(String.format(" Socket >> %s Sending packet to %s(%d)", new Date().toString(), p.getAddress().toString(), p.getPort()));
        this.socket.send(p);
    }
    public void receive(DatagramPacket p) throws IOException{
        this.socket.receive(p);
        Console.info(String.format(" Socket >> %s Received packet from %s(%d)", new Date().toString(), p.getAddress().toString(), p.getPort()));
    }
    public void close(){
        Console.info(String.format(" Socket >> %s Closing socket", new Date().toString()));
        this.socket.close();
    }

    @Override
    public void setTimeout(int time) throws SocketException {
        this.socket.setSoTimeout(time);
    }
}
package com.client.socket;

import com.client.pack.Pack;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.util.Random;

/**
 * Created by lhtan on 24/3/16.
 */
public class KisiaoSocket extends WrapperSocket {
    private final Random random;
    private final double prob;

    public KisiaoSocket(Socket socket, double probability) {
        super(socket);
        this.random = new Random();
        this.prob = probability;
    }

    @Override
    public void send(Pack pack, InetAddress address, int port) throws IOException {
        if (isSoSuay()) {
            byte[] rubbish = new byte[200];
            fillRubbish(rubbish);
            super.send(new Pack.Builder().setValue("rubbish", rubbish).build(), address, port);
        }else{
            super.send(pack, address, port);
        }
    }

    @Override
    public void send(DatagramPacket p) throws IOException {
        if (isSoSuay()) fillRubbish(p.getData());
        super.send(p);
    }

//    @Override
//    public void receive(DatagramPacket p) throws IOException {
//        super.receive(p);
//        if (isSoSuay()) fillRubbish(p.getData());
//    }

    private void fillRubbish(byte[] data) {
        this.random.nextBytes(data);
    }

    private boolean isSoSuay(){
        return this.random.nextDouble() >= this.prob;
    }
}
package com.client.socket;

import com.client.pack.Pack;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.InetAddress;

/**
 * Created by lhtan on 24/3/16.
 */
public class LagSocket extends WrapperSocket {
    private final int time;

    /**
     * @param time lag for this number of millisecond when sending or receiving packet
     */
    public LagSocket(Socket socket, int time) {
        super(socket);
        this.time = time;
    }

    @Override
    public void send(Pack pack, InetAddress address, int port) throws IOException {
        lag();
        super.send(pack, address, port);
    }

    @Override
    public void send(DatagramPacket p) throws IOException {
        lag();
        super.send(p);
    }

    @Override
    public void receive(DatagramPacket p) throws IOException {
        super.receive(p);
        lag();
    }

    private void lag(){
        try {
            Thread.sleep(this.time);
        } catch (InterruptedException e) {
        }
    }
}
package com.client.socket;

import com.Console;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.SocketTimeoutException;
import java.util.Random;

/**
 * Created by lhtan on 23/3/16.
 */
public class NoobReceiveSocket extends WrapperSocket {
    private final Random random;
    private final double prob;
    public NoobReceiveSocket(Socket socket, double probability) {
        super(socket);
        this.random = new Random();
        this.prob = probability;
    }

    @Override
    public void receive(DatagramPacket p) throws IOException, SocketTimeoutException {
        //5% of packet loss, simulating at most once
        if (random.nextDouble() < this.prob){
            super.receive(p);
        }else{
            //sleep for a while, or else too fast
            try {
                Thread.sleep(1000);
                Console.info("  NoobReceiveSocket >> Fake Packet Loss when receiving");
            } catch (InterruptedException e) {
            }
            throw new SocketTimeoutException();
        }
    }
}
package com.client.socket;

import com.Console;
import com.client.pack.Pack;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.util.Random;

/**
 * Created by lhtan on 23/3/16.
 */
public class NoobSendSocket extends WrapperSocket {
    private final Random random;
    private final double prob;
    public NoobSendSocket(Socket socket, double probability) {
        super(socket);
        this.random = new Random();
        this.prob = probability;
    }

    @Override
    public void send(Pack pack, InetAddress address, int port) throws IOException {
        if (random.nextDouble() < this.prob){
            super.send(pack, address, port);
        }else{
            //sleep for a while, or else too fast
            try {
                Thread.sleep(1000);
                Console.info("  NoobSendSocket >> Fake Packet Loss when sending");
            } catch (InterruptedException e) {
            }
        }
    }

    @Override
    public void send(DatagramPacket p) throws IOException {
        if (random.nextDouble() < this.prob){
            super.send(p);
        }else{
            //sleep for a while, or else too fast
            try {
                Thread.sleep(1000);
                Console.info("  NoobSendSocket >> Fake Packet Loss when sending");
            } catch (InterruptedException e) {
            }
        }
    }
}
package com.client.socket;

import com.Console;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketTimeoutException;
import java.util.Random;

/**
 * Created by lhtan on 23/3/16.
 */
public class NoobSocket extends BoboSocket {
    private final Random random;
    public NoobSocket(DatagramSocket socket) {
        super(socket);
        random = new Random();
    }

    @Override
    public void send(DatagramPacket p) throws IOException {
        //5% of packet loss, simulating at most once
        if (random.nextInt(20) < 19){
            super.send(p);
        }else{
            //sleep for a while, or else too fast
            try {
                Thread.sleep(1000);
                Console.info(" NoobSocket >> Fake Packet Loss when sending");
            } catch (InterruptedException e) {
            }
        }
    }

    @Override
    public void receive(DatagramPacket p) throws IOException, SocketTimeoutException {
        //5% of packet loss, simulating at most once
        if (random.nextInt(20) < 19){
            super.receive(p);
        }else{
            //sleep for a while, or else too fast
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
            }
            throw new SocketTimeoutException();
        }
    }
}
package com.client.socket;

import com.client.pack.Pack;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.SocketException;

/**
 * Created by lhtan on 24/3/16.
 */
public interface Socket {
    void send(Pack pack, InetAddress address, int port) throws IOException;
    void send(DatagramPacket p) throws IOException;
    void receive(DatagramPacket p) throws IOException;
    void close();
    void setTimeout(int time) throws SocketException;
}
package com.client.socket;

import com.client.pack.Pack;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.SocketException;

/**
 * Created by lhtan on 24/3/16.
 */
public class WrapperSocket implements Socket {

    private final Socket socket;

    public WrapperSocket(Socket socket) {
        this.socket = socket;
    }

    @Override
    public void send(Pack pack, InetAddress address, int port) throws IOException {
        this.socket.send(pack, address, port);
    }

    @Override
    public void send(DatagramPacket p) throws IOException {
        this.socket.send(p);
    }

    @Override
    public void receive(DatagramPacket p) throws IOException {
        this.socket.receive(p);
    }

    @Override
    public void close() {
        this.socket.close();
    }

    @Override
    public void setTimeout(int time) throws SocketException {
        this.socket.setTimeout(time);
    }
}
package com;

import java.util.Scanner;

/**
 * Created by lhtan on 23/3/16.
 */
public class Console {

    public static boolean showInfo = true;

    private Scanner scanner;
    public Console(Scanner scanner) {
        this.scanner = scanner;
    }

    public int askForInteger(String question){
        System.out.println(question);
        while(true) {
            try {
                return Integer.parseInt(scanner.nextLine());
            } catch (NumberFormatException e) {
            }
        }
    }
    public String askForString(String question){
        System.out.println(question);
        return scanner.nextLine();
    }

    public static void println(String line){
        System.out.println(line);
    }
    public static void info(String line){
        if (showInfo)   System.out.println(line);
    }
}
package com;

import com.client.Client;
import com.client.cache.FileCache;
import com.client.cache.Cache;
import com.client.fucker.*;

import java.util.Scanner;

/**
 * Created by lhtan on 22/3/16.
 */
public class Main {
    public static void main(String[] args) {
        //hide those mahuan stuff
        Console.showInfo = false;

        Client client = null;
        Scanner reader = new Scanner(System.in);
        Console console = new Console(reader);
        String cacheFolder = "/Users/lhtan/IdeaProjects/Client/data";

        Cache cache = new FileCache(cacheFolder, 30);
        try {
            client = new Client("10.27.124.59", 6789, 5000) //30000)  //30 second timeout
                        .use(1, new PingFucker())
                        .use(2, new ReadingFucker())
                        .use(3, new WritingFucker())
                        .use(4, new RegisterFucker(cache))
                        .use(5, new SizeFucker())
                        .use(6, new DoubleFucker())
                        .use(7, new LastModifiedFucker())
                        .use(8, new CacheFucker(cache))
                        .use(9, new CacheReadingFucker(cache))
                        .use(10, new CacheWritingFucker(cache))
                        .use(11, new CacheDetailFucker(cache))
//                        .makeItKisiao(.2)
//                        .makeItNoobInReceiving(.3)
//                        .makeItNoobInSending(.8)
//                        .makeItLag(1000)
                        ;
            mainLoop: while(true) {
                int option = printMenu(reader, client);
                if (option == 99){
                    break mainLoop;
                }
                //execute
                client.execute(option, console);
                //
                System.out.println();
            }

        }catch (Exception e){
            Console.info("Fuck why got error!!! CiBaI");
            e.printStackTrace();
        }finally {
            if (client != null){
                client.stop();
            }
        }
    }
    public static int printMenu(Scanner scanner, Client client){
        int option = -1;
        while(option <= 0 || option > 99) {
            Console.println("=== This is the main menu of Bobo ===");
            Console.println("Choose any of the following option");
            client.printMenu();
            Console.println("99. Exit");
            try {
                option = Integer.parseInt(scanner.nextLine());
            }catch (NumberFormatException e){
            }
        }
        return option;
    }
}
